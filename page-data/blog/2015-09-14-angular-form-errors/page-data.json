{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/2015-09-14-angular-form-errors/","result":{"data":{"mdx":{"id":"c34c5b70-dc58-50b4-a2b2-f8a19353415b","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"Angular Form Errors\",\n  \"date\": \"2015-09-15T05:11:38.000Z\",\n  \"comments\": true,\n  \"tags\": [\"angular\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"One of the most frustrating UX pitfalls, one which people new to Angular often utilize, is disabling buttons\\nto show that a form is not yet valid (ng-disabled). A user that is looking for the input button probably thinks they have finished\\nentering their details, but a disabled button leaves them stuck. A better solution is an interactive form, that\\nhighlights errors when a user attempts to advance when the form is invalid.\"), mdx(\"p\", null, \"To solve this I have created 3 core directives which will be placed throughout a form to allow for a much better user experience.\"), mdx(\"p\", null, \"To start we will implement a simpler version with the first two directives, then add the third one in after.\"), mdx(\"p\", null, \"In angular each form element (or ng-form attribute) will create a new formController. This controller--stored on the scope\\nunder the form's name--can be leveraged to determine the validity of the form. The 3 directives will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsSubmit\"), \",\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsForm\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrors\"), \". The way they will work is that all errors will start\\nhidden from the user, regardless of the forms current validity state. Once the user is done submitting their\\ninformation they will hit the submit button which will have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsSubmit\"), \" directive on it.\\nThis directive will ensure that the form is valid before submitting. If the form is\\ninvalid it will block the ng-submit/ng-click action of the button, and then signal the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsForm\"), \" directive that an invalid submission\\nwas triggered. Then the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsForm\"), \" directive will apply the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reveal-errors\"), \" class to the form, as well as find the first\\ninvalid input field and scroll to that position. With the new class applied we will have the error revealed for the user to fix.\\nThe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrors\"), \" directive will allow for greater fine tuning as well as house the communication data (class names and event names).\"), mdx(\"p\", null, \"To start we need a new module, or use your existing app. I have written these in typescript for legibility, but\\nyou can view their javascript equivalents by using the toggle. I definitely recommend learning TypeScript though, as\\nit makes writing and maintaining large apps much easier.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\",\n    \"metastring\": \"title=csErrors\\\\module\\\\setup\",\n    \"title\": \"csErrors\\\\module\\\\setup\"\n  }), \"module cs {\\n  export var csErrors: ng.IModule = angular.module('csErrors', []);\\n}\\n\")), mdx(\"p\", null, \"#csErrorsSubmit\"), mdx(\"p\", null, \"Let's setup the first directive's definition.\"), mdx(\"p\", null, \"We give the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsSubmit\"), \" directive a scope false, because this directive isn't applying any new elements or any new packaged\\ncontent that would require a new scope context, it is simply adding additional functionality to what already functions.\\nIt will also need access to the form, require the form using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"^form\"), \" to have access to the current scope's form for validity checks.\"), mdx(\"p\", null, \"It needs a priority of -1 to ensure that the link function is run before the link function of ng-click and ng-submit which both\\nhave the default priority of 0. We use -1 because although the controller functions are run according to their priority, the\\nlink function is run in reverse order of priority. Since the click event is added in the link function for ng-click, we will\\ndo the same. We also want to use the link function because it is taboo to inject the element into the controller, as well as we are doing mostly\\nDOM work.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"You'll notice I'm prefixing my directives with cs (CodySchaaf) since errors is a bit common, this will prevent any\\nclashes with future angular version that might release a directive with the same name, or future html standards that\\ncould release an attribute with the same name; sort of like Angular's ng\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"csErrorsSubmit directive\",\n    \"csErrorsSubmit\": true,\n    \"directive\": true\n  }), \"cs.csErrors.directive(\\n  'csErrorsSubmit',\\n  (): ng.IDirective => {\\n    return {\\n      restrict: 'A',\\n      scope: false,\\n      require: '^form',\\n      priority: -1, //ensure it is run before ng-click with a 0 priority since link functions are run in reverse order\\n      link: (scope: Scope, element: ng.IAugmentedJQuery, attrs: Attr, formCtrl: ng.IFormController): Link => {\\n        return new Link(scope, element, attrs, formCtrl);\\n      },\\n    };\\n  },\\n);\\n\")), mdx(\"p\", null, \"In the link function we will setup the on click event. The handler will check that the formCtrl is valid, if it is invalid\\nit will emit an event. This event is composed of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"REVEAL_ERRORS_EVENT\"), \" name and the form's name. We want to make it specific\\nto the form because we could have these setups nested and we want to ensure that we are talking to the correct form. We use \\\\$emit instead\\nof broadcast because the submit button will be nested inside the form and emit propagates up the scope.\"), mdx(\"p\", null, \"This works because of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.angularjs.org/api/ng/type/form.FormController\"\n  }), \"Angular's awesome form handling\"), \".\\nAs long as you attach the appropriate \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.angularjs.org/api/ng/directive/ngModel\"\n  }), \"ng-model validating directives\"), \"\\nto your inputs, this will be able to tell if the form is valid. This is because a form is only valid if all of the children\\nng-models are valid. So--for example--by adding \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.angularjs.org/api/ng/directive/ngRequired\"\n  }), \"ng-required\"), \"\\nto all fields, the form will only be valid if all fields are answered and thus\\nthis will only submit if all fields are answered.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"csErrorsSubmit's link function\",\n    \"csErrorsSubmit's\": true,\n    \"link\": true,\n    \"function\": true\n  }), \"class Link {\\n  constructor(scope: Scope, element: ng.IAugmentedJQuery, attrs: Attr, formCtrl: ng.IFormController) {\\n    element.on('click', (event: JQueryEventObject) => {\\n      if (formCtrl.$invalid) {\\n        scope.$emit(cs.errors.Link.REVEAL_ERRORS_EVENT + formCtrl.$name);\\n        event.preventDefault();\\n        event.stopImmediatePropagation();\\n      }\\n    });\\n  }\\n}\\n\\ninterface Attr extends ng.IAttributes {\\n  errorsSubmit: string;\\n}\\n\\ninterface Scope extends ng.IScope {\\n  formCtrl: FormCtrl;\\n  attrs: Attr;\\n}\\n\")), mdx(\"p\", null, \"Additionally we can bake in some protection by checking that this button corresponds with the intended target form. We will\\nrequire that users of the directive pass in the name of the intended form. Then we check it against the name of the form\\nthat require found \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"errors-submit='form-name'\"), \".\"), mdx(\"p\", null, \"This leaves us with:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"csErrorsSubmit's link function\",\n    \"csErrorsSubmit's\": true,\n    \"link\": true,\n    \"function\": true\n  }), \"class Link {\\n  constructor(scope: Scope, element: ng.IAugmentedJQuery, attrs: Attr, formCtrl: ng.IFormController) {\\n    element.on('click', (event: JQueryEventObject) => {\\n      if (attrs.errorsSubmit !== formCtrl.$name) {\\n        throw 'Provided name (' + attrs.errorsSubmit + ') of form does not match:' + formCtrl.$name;\\n      }\\n      if (formCtrl.$invalid) {\\n        scope.$emit(cs.errors.Link.REVEAL_ERRORS_EVENT + formCtrl.$name);\\n        event.preventDefault();\\n        event.stopImmediatePropagation();\\n      }\\n    });\\n  }\\n}\\n\\ninterface Attr extends ng.IAttributes {\\n  errorsSubmit: string;\\n}\\n\\ninterface Scope extends ng.IScope {\\n  formCtrl: FormCtrl;\\n  attrs: Attr;\\n}\\n\")), mdx(\"p\", null, \"#csErrorsForm\"), mdx(\"p\", null, \"Once this directive emits its event we will need something to catch it, in comes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsForm\"), \".\"), mdx(\"p\", null, \"We will start with the directive definition, with just a scope false and link function:\"), mdx(\"p\", null, \"For the implementation of the link function, we need access to the scope, the element, and the element's attributes.\"), mdx(\"p\", null, \"The element is needed to add and remove the error classes. It will add a hide errors class on initialization, and then\\nremove that class, as well as add a reveal errors class once it receives the event from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsSubmit\"), \" directive.\\nThis even will be listened to by the scope, with a scope.\\\\$on, and finally the attributes to get the form name and whether or\\nnot you want the directive to scroll to fields that are invalid.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"csErrorsForm directive\",\n    \"csErrorsForm\": true,\n    \"directive\": true\n  }), \"cs.csErrors.directive(\\n  'csErrorsForm',\\n  (): ng.IDirective => {\\n    return {\\n      restrict: 'A',\\n      scope: false,\\n      link: (scope: ng.IScope, element: ng.IAugmentedJQuery, attrs: Attrs): Link => {\\n        return new Link(scope, element, attrs);\\n      },\\n    };\\n  },\\n);\\n\")), mdx(\"p\", null, \"First thing we do during initialization is add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HIDE_ERRORS_CLASS\"), \", this will allow you to target the form\\nwith pre-validation specific css.\"), mdx(\"p\", null, \"Next we listen for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"REVEAL_ERRORS_EVENT\"), \" that was emitted by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsSubmit\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"scope.$on(cs.errors.Link.REVEAL_ERRORS_EVENT + attrs.name...\"), \"\\nYou can see here that we are adding the form name to the event name to ensure that the message is intended for this form.\\nThis is to allow form nesting, you could also accomplish this by stopping the propagation, but I think this is more precise.\\nThe form name is pulled in from the form or ng-form element that this directive is placed on, since all forms should have a name attribute.\"), mdx(\"p\", null, \"Once we received this event we will add and remove the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"REVEAL_ERRORS_CLASS\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HIDE_ERRORS_CLASS\"), \" respectively. This will allow\\nyour css to apply errors for the invalid fields based on the form's current class coupled with Angular's invalid classes on inputs with\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ng-model\"), \".\"), mdx(\"p\", null, \"Finally we will want to determine if the implementation wants us to scroll, specified by omitting the no-scroll string\\nto the directive instance \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<div cs-errors-form>\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<div cs-errors-form='no-scroll'>\"), \". If no-scroll is passed in we just return,\\notherwise we search for the first instance of an elements with the ng-invalid class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"element.find(\\\".ng-invalid\\\").first()\"), \". If we find one\\nwe use the baked in jquery scroll animation to scroll to it.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Tip: us no scroll for small forms like login where scrolling would be more distracting than helpful\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"csErrorsForm's link function\",\n    \"csErrorsForm's\": true,\n    \"link\": true,\n    \"function\": true\n  }), \"class Link {\\n  constructor(scope: ng.IScope, element: ng.IAugmentedJQuery, attrs: Attrs) {\\n    element.addClass(cs.cs.errors.Link.HIDE_ERRORS_CLASS);\\n    scope.$on(cs.errors.Link.REVEAL_ERRORS_EVENT + attrs.name, (): void => {\\n      element.addClass(cs.errors.Link.REVEAL_ERRORS_CLASS).removeClass(cs.errors.Link.HIDE_ERRORS_CLASS);\\n      if (attrs.csErrorsForm === 'no-scroll') {\\n        return;\\n      }\\n\\n      var firstErroredElement: JQuery = element.find('.ng-invalid').first();\\n      if (firstErroredElement.length !== 0) {\\n        angular.element('html, body').animate(\\n          {\\n            //animate the scroll to the invalid input\\n            scrollTop: firstErroredElement.offset().top - 100, //100 px padding on scroll to top\\n          },\\n          600,\\n        );\\n      }\\n    });\\n  }\\n}\\n\\ninterface Attrs extends ng.IAttributes {\\n  name: string;\\n  csErrorsForm?: string;\\n}\\n\")), mdx(\"p\", null, \"Now for the styling. The first thing you will want to apply your non-error state styles to elements with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ng-invalid\"), \" class.\\nMost Angular apps will have invalid styles applied to their ui components by targeting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ng-invalid\"), \" class.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-css\"\n  }), \"input.ng-invalid {\\n  border-color: red;\\n}\\n\")), mdx(\"p\", null, \"Undo this styling if the element is located inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cs-errors-form\"), \" directive.\\nThis will allow the input element to appear valid even if the user has failed to enter a valid input yet. Allowing the form\\nto look pristine even if the user has yet to interact with it. There is also the ability to target ng-pristine, but that leaves\\nyou helpless when a user has left a field pristine and is trying to submit the form. Ng-pristine is also clumsy and not super\\ncross browser friendly (I'm looking at you IE).\"), mdx(\"p\", null, \"As the comment suggests this is also where you could add custom directives that utilize ng-model validations, like a\\ndate picker for example.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sass\"\n  }), \"\\n[cs-errors-form] {\\n    //place any additional custom input field un-styling in here\\n    input.ng-invalid, textarea.ng-invalid, select.ng-invalid { // [date-picker].ng-invalid input\\n        //override standard invalid state\\n        @include valid-input;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Followed by adding back in your error mixins if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cs-errors-form\"), \" has the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reveal-errors\"), \" class. Adding a little\\npolish by again applying the valid styles if the element is focused.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sass\"\n  }), \"\\n[cs-errors-form] {\\n    //place any additional custom input field un-styling in here\\n    input.ng-invalid, textarea.ng-invalid, select.ng-invalid { // [date-picker].ng-invalid input\\n        //override standard invalid state\\n        @include valid-input;\\n    }\\n\\n    &.reveal-errors {\\n        //place any additional custom input field re-styling in here\\n        input.ng-invalid, textarea.ng-invalid, select.ng-invalid { //[date-picker].ng-invalid input\\n            //override standard invalid state\\n            @include invalid-input;\\n            &:focus {\\n                @include valid-input;\\n            }\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Finally lets add some styles to our error messages, that will utilize \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.angularjs.org/api/ngMessages\"\n  }), \"Angualr's \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"ng-messages\"), \" directive\"), \".\\nAnd tying it all together\\nwe have:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sass\"\n  }), \"@mixin cs-errors-hide-error() {\\n    height: 0px;\\n    margin-top: 0px;\\n    margin-bottom: 0px;\\n    opacity: 0;\\n}\\n\\n@mixin cs-errors-reveal-error() {\\n    $animationLength: .4s;\\n    height: 20px;\\n    margin-top: 5px;\\n    margin-bottom: 10px;\\n    opacity: 1;\\n    @extend .cs-animate.slide-and-fade; //see part 3 for the animations, or leave them out, up to you.\\n}\\n\\n[cs-errors-form] {\\n    .text-danger {\\n        @include cs-errors-hide-error;\\n    }\\n    //place any additional custom input field un-styling in here\\n    input.ng-invalid, textarea.ng-invalid, select.ng-invalid { // [date-picker].ng-invalid input\\n        //override standard invalid state\\n        @include valid-input;\\n    }\\n\\n    &.reveal-errors {\\n        //place any additional custom input field re-styling in here\\n        input.ng-invalid, textarea.ng-invalid, select.ng-invalid { //[date-picker].ng-invalid input\\n            //override standard invalid state\\n            @include invalid-input;\\n            &:focus {\\n                @include valid-input;\\n            }\\n        }\\n\\n        .text-danger {\\n            @include cs-errors-reveal-error;\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Let's see what that would like like in your view. Bellow I'm utilizing ng-messages to show the errors. This\\nallows for really clean and consistent error handling.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Remember that when installing ng-messages you have to include the new script tag, as well as inject the module into your app.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-html\"\n  }), \"<form name=\\\"userForm\\\" cs-errors-form novalidate>\\n    <div class=\\\"form-group\\\">\\n        <input type=\\\"text\\\"  name=\\\"name\\\" ng-model=\\\"user.name\\\" ng-required=\\\"true\\\" placeholder=\\\"name\\\"/>\\n        <div ng-messages=\\\"userForm.name.$error\\\">\\n            <p class=\\\"text-danger\\\" ng-message=\\\"required\\\">You forgot your name.</p>\\n\\n\\n\\n    <div class=\\\"form-group\\\">\\n        <input type=\\\"text\\\"  name=\\\"number\\\" ng-model=\\\"user.number\\\" ng-minlength=\\\"7\\\" ng-required=\\\"true\\\" placeholder=\\\"number\\\"/>\\n        <div ng-messages=\\\"userForm.number.$error\\\">\\n            <p class=\\\"text-danger\\\" ng-message=\\\"required\\\">You forgot your number.</p>\\n            <p class=\\\"text-danger\\\" ng-message=\\\"minlength\\\">Your number is too short.</p>\\n\\n\\n\\n    <button cs-errors-submit=\\\"userForm\\\" ng-click=\\\"save()\\\">Create User</button>\\n</form>\\n\\n\")), mdx(\"p\", null, \"At this point we have a working yet admittedly naive error handling. It will provide a good user experience for users that\\nhave forgotten to fill out a field, but for users that have incorrectly filled out a field, they will have to wait till\\nthey try to submit it to see an error.\"), mdx(\"p\", null, \"To fix this we will introduce another directive, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cs-errors\"), \" directive. This will attach a blur event handler to\\nthe field as well as apply the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reveal-errors\"), \" class to this element on blur. At this point we should transition to targeting this\\nclass for most input specific error styles.\"), mdx(\"p\", null, \"Doing this will give the user instant feedback on invalid fields, but won't mark the field as invalid until they are\\ndone trying to enter valid information. It would be annoying to do this on focus because then they would be berated with\\nerrors before they were done.\"), mdx(\"p\", null, \"This directive will be attached to all form-groups (optional to add the class, but helps if you are using bootstrap). We'll start with\\nthe directive declaration.\"), mdx(\"p\", null, \"We give it a scope false, because this directive isn't applying any new elements or any new packaged\\ncontent that would require a new scope context, it is simply adding additional functionality to what already exists.\"), mdx(\"p\", null, \"I'm using the link function here because we need access to the directive element and we are doing mostly DOM logic. Also\\nwe want this to run after the DOM has been rendered, as well as to have access to Angular's formController.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"csErrors directive\",\n    \"csErrors\": true,\n    \"directive\": true\n  }), \"cs.csErrors.directive(\\n  'csErrors',\\n  (): ng.IDirective => {\\n    return {\\n      restrict: 'A',\\n      scope: false,\\n      link: (scope: ng.IScope, elem: ng.IAugmentedJQuery): Link => {\\n        if (!elem.hasClass('form-group')) {\\n          throw \\\"errors element does not have the 'form-group' class\\\";\\n        }\\n        return new Link(scope, elem);\\n      },\\n    };\\n  },\\n);\\n\")), mdx(\"p\", null, \"This is where I have chosen to store the static variables used in the other directives, at the top we have the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"REVEAL_ERRORS_CLASS\"), \" which is the name of the class we need to add to the element when it\\nis time to reveal the errors, as well as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"REVEAL_ERRORS_EVENT\"), \". We pass the scope and the element to the constructor.\"), mdx(\"p\", null, \"First we want to do a quick check to ensure we have the correct elements in the form-group to work with, so we check for\\nan element with a name. This allows this directive to work with any ui component that uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ng-model\"), \" validation, since we\\nare not limiting it to inputs, with a name we can even just have an inner ng-form that monitors the directives validity.\"), mdx(\"p\", null, \"After that we will set up our on blur handler. If you need to get fancier with your on blur you can pass in a a config object that\\nwill allow you to select on different elements, which will allow you to use more advanced/custome ui-components (more on this is\\npart 2).\"), mdx(\"p\", null, \"With the scope we listen for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"REVEAL_ERRORS_EVENT\"), \" which we will catch after it is emitted from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsForm\"), \".\"), mdx(\"p\", null, \"With these two methods of adding a class we cover both uses cases, of a person entering wrong info and then moving on, as well\\nas missing the field and attempting to submit the invalid form.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"csErrors's link function\",\n    \"csErrors's\": true,\n    \"link\": true,\n    \"function\": true\n  }), \"module cs.errors {\\n  export class Link {\\n    public static REVEAL_ERRORS_EVENT: string = 'RevealErrors:';\\n    public static REVEAL_ERRORS_CLASS: string = 'reveal-errors';\\n    public static HIDE_ERRORS_CLASS: string = 'hide-errors';\\n\\n    constructor(private scope: ng.IScope, private element: ng.IAugmentedJQuery) {\\n      var inputEl: ng.IAugmentedJQuery = element.find('[name]');\\n      var inputName: string = inputEl.attr('name');\\n      if (!inputName) {\\n        throw \\\"cs-errors element has no child input elements with a 'name' attribute\\\";\\n      }\\n\\n      inputEl.on('blur', this.toggleClasses.bind(this));\\n      this.scope.$on(Link.REVEAL_ERRORS_EVENT, this.toggleClasses.bind(this));\\n    }\\n\\n    private enableErrors(): void {\\n      this.element.addClass(Link.REVEAL_ERRORS_CLASS);\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now lets update our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsForm\"), \" link function to communicate the event received from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csErrorsSubmit\"), \" to all the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"form-groups\"), \"\\nit contains.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"scope.$broadcast(cs.errors.Link.REVEAL_ERRORS_EVENT); //no longer needs form name namespace since broadcasting down to all children\\n\")), mdx(\"p\", null, \"All together we have\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"csErrors's link function\",\n    \"csErrors's\": true,\n    \"link\": true,\n    \"function\": true\n  }), \"class Link {\\n  constructor(scope: ng.IScope, element: ng.IAugmentedJQuery, attrs: Attrs) {\\n    element.addClass(cs.errors.Link.HIDE_ERRORS_CLASS);\\n    scope.$on(cs.errors.Link.REVEAL_ERRORS_EVENT + attrs.name, (): void => {\\n      scope.$broadcast(cs.errors.Link.REVEAL_ERRORS_EVENT); //no longer needs form name namespace since broadcasting down to all children\\n      element.addClass(cs.errors.Link.REVEAL_ERRORS_CLASS).removeClass(cs.errors.Link.HIDE_ERRORS_CLASS);\\n      if (attrs.csErrorsForm === 'no-scroll') {\\n        return;\\n      }\\n\\n      var firstErroredElement: JQuery = element.find('.ng-invalid').first();\\n      if (firstErroredElement.length !== 0) {\\n        angular.element('html, body').animate(\\n          {\\n            scrollTop: firstErroredElement.offset().top - 100, //100 px padding on scroll to top\\n          },\\n          600,\\n        );\\n      }\\n    });\\n  }\\n}\\n\\ninterface Attrs extends ng.IAttributes {\\n  name: string;\\n  csErrorsForm?: string;\\n}\\n\")), mdx(\"p\", null, \"And now to update the styles to target the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"form-groups\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sass\"\n  }), \"\\n[cs-errors-form] [cs-errors].form-group {\\n    .text-danger {\\n        @include cs-errors-hide-error;\\n    }\\n    //place any additional custom input field un-styling in here\\n    input.ng-invalid, textarea.ng-invalid, select.ng-invalid { // [date-picker].ng-invalid input\\n        //override standard invalid state\\n        @include valid-input;\\n    }\\n\\n    &.reveal-errors {\\n        //place any additional custom input field re-styling in here\\n        input.ng-invalid, textarea.ng-invalid, select.ng-invalid { //[date-picker].ng-invalid input\\n            //override standard invalid state\\n            @include invalid-input;\\n            &:focus {\\n                @include valid-input;\\n            }\\n        }\\n\\n        .text-danger {\\n            @include cs-errors-reveal-error;\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"And finally updated html\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-html\"\n  }), \"<form name=\\\"userForm\\\" cs-errors-form novalidate>\\n    <div class=\\\"form-group\\\" cs-errors>\\n        <input type=\\\"text\\\"  name=\\\"name\\\" ng-model=\\\"user.name\\\" ng-required=\\\"true\\\"/>\\n        <div ng-messages=\\\"userForm.name.$error\\\">\\n            <p class=\\\"text-danger\\\" ng-message=\\\"required\\\">You forgot your name.</p>\\n\\n\\n\\n    <div class=\\\"form-group\\\" cs-errors>\\n        <input type=\\\"text\\\"  name=\\\"name\\\" ng-model=\\\"user.number\\\" ng-minlength=\\\"7\\\" ng-required=\\\"true\\\"/>\\n        <div ng-messages=\\\"userForm.name.$error\\\">\\n            <p class=\\\"text-danger\\\" ng-message=\\\"required\\\">You forgot your number.</p>\\n            <p class=\\\"text-danger\\\" ng-message=\\\"minlength\\\">Your number is too short.</p>\\n\\n\\n\\n    <button cs-errors-submit=\\\"userForm\\\" ng-click=\\\"save()\\\">Create User</button>\\n</form>\\n\\n\")), mdx(\"p\", null, \"Here is a working example using my \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/CodySchaaf/CsAngularErrors\"\n  }), \"csErrors\"), \" module which can also be installed\\nas a bower\\nplugin with the name cs-angular-errors.\"), mdx(\"iframe\", {\n    height: \"265\",\n    style: {\n      \"width\": \"100%\"\n    },\n    scrolling: \"no\",\n    title: \"Angular Form Validation - CsAngularErrors\",\n    src: \"https://codepen.io/codyschaaf/embed/qONaJw?height=265&theme-id=light&default-tab=css,result\",\n    frameBorder: \"no\",\n    loading: \"lazy\",\n    allowtransparency: \"true\",\n    allowFullScreen: true\n  }, \"See the Pen \", mdx(\"a\", {\n    href: \"https://codepen.io/codyschaaf/pen/qONaJw\"\n  }, \" Angular Form Validation - CsAngularErrors \"), \" by Cody Schaaf (\", mdx(\"a\", {\n    href: \"https://codepen.io/codyschaaf\"\n  }, \"@codyschaaf\"), \") on \", mdx(\"a\", {\n    href: \"https://codepen.io\"\n  }, \" CodePen \"), \".\"), mdx(\"p\", null, \"This is enough to get most basic forms up and running, there are a few edge cases that we need to work out in part 2;\\nsuch as when you have a directive that encapsulates a ui component that is used for input. This will not be rendered in time\\nto get the form setup. As well as if you have multiple inputs for a single model (like seperate first and last name fields).\"), mdx(\"p\", null, \"And finally check back for part 3 where I will go over the animations.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Angular Form Errors","date":"September 15th, 2015","tags":["angular"]}}},"pageContext":{"id":"c34c5b70-dc58-50b4-a2b2-f8a19353415b"}},"staticQueryHashes":["3649515864","3897982121","3897982121"]}