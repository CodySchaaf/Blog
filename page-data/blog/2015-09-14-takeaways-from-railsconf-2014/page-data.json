{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/2015-09-14-takeaways-from-railsconf-2014/","result":{"data":{"mdx":{"id":"3f95e968-8397-5356-a5ab-0c76123d1b8f","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"Takeaways From RailsConf 2014\",\n  \"date\": \"2014-05-14T02:09:01.000Z\",\n  \"comments\": true,\n  \"categories\": null\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Once everyone got passed the 'The Death To TDD' hysteria, this years\\nmost influential talks focused heavily on refactoring. This was\\nmy first Rails conference, and while I have alway attempted to write maintainable\\nand clean code, I was always a little gun-shy when it came to massive refactoring.\\nWhen do you break something into a new class, and when is a method too long?\"), mdx(\"p\", null, \"Starting a little simpler, one of my favorite talks was actually a workshop\\non day one. It was with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://tutecosta.com/\"\n  }), \"Tute Costa\"), \", where he took us\\nthrough some short examples of some really chaotic code, and after giving us\\na few pointers, he set us loose on refactoring it.\"), mdx(\"p\", null, \"##Taming the Flow of Control\"), mdx(\"p\", null, \"We started out with one of my favorite refactoring techniques, mostly because\\nit is so simple and the least disrupting of the refactoring techniques yet can\\nstill make a huge difference in readability. This is the code he gave us:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"1-intention-revealing-method https://github.com/tute/refactoring-workshop/blob/master/1-intention-revealing-method/app.rb Link To Full Source\",\n    \"1-intention-revealing-method\": true,\n    \"https://github.com/tute/refactoring-workshop/blob/master/1-intention-revealing-method/app.rb\": true,\n    \"Link\": true,\n    \"To\": true,\n    \"Full\": true,\n    \"Source\": true\n  }), \"\\nclass ProjectsController\\n  def index\\n    # When user is admitted at least a week ago we show it's active projects\\n    if current_user && current_user.created_at < (Time.now - 7*24*3600)\\n      @projects = current_user.active_projects\\n\\n    # If not admitted we show some featured projects, and set a marketing flash\\n    # message when user is new\\n    else\\n      if current_user && current_user.created_at > (Time.now - 7*24*3600)\\n        @flash_msg = 'Sign up for having your own projects, and see promo ones!'\\n      end\\n      @projects = Project.featured\\n    end\\n  end\\nend\\n\\n\")), mdx(\"p\", null, \"He told us that a simple technique he uses is to just take the comment, and\\nconvert it into the method name that is called by the if statement. Here is what\\nI did:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"My Revision\",\n    \"My\": true,\n    \"Revision\": true\n  }), \"\\nclass ProjectsController\\n  def index\\n\\n    if user_created_more_than_a_week_ago?\\n      @projects = current_user.active_projects\\n    else\\n      @flash_msg = 'Sign up for having your own projects, and see promo ones!'\\n      @projects = Project.featured\\n    end\\n  end\\n\\n  def user_created_more_than_a_week_ago?\\n    current_user && current_user.created_at <  weeks_ago(1)\\n  end\\n\\n  def weeks_ago(n)\\n    Time.now - n * 7*24*3600\\n  end\\n\\nend\\n\\n\")), mdx(\"p\", null, \"As you can see the first long cryptic if statement was easily reduced to a much\\nmore readable sentence-like method. Further more through this process it became\\nclear that the nested if check wasn't even needed.\"), mdx(\"p\", null, \"##Polymorphism at its Finest\"), mdx(\"p\", null, \"I had never used polymorphism quite like this before. Instead of constantly checking\\nthat the object we are dealing with can respond to a given method, we simply ensure that all\\nobjects at this point in the code have some way of responding to it. Now when I put\\nit like that it sounds so obvious. But what about when we don't find the object we are looking for.\\nWhy shouldn't the same concept still apply here. This is the idea that was presented to\\nuse before we started to takle this next part.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"2-special-case-objects https://github.com/tute/refactoring-workshop/blob/master/2-special-case-objects/app.rb Link To Full Source\",\n    \"2-special-case-objects\": true,\n    \"https://github.com/tute/refactoring-workshop/blob/master/2-special-case-objects/app.rb\": true,\n    \"Link\": true,\n    \"To\": true,\n    \"Full\": true,\n    \"Source\": true\n  }), \"\\nclass StatusReportJob\\n  def perform\\n    users = {}\\n    User.all.map do |user|\\n      users[user.name] = {\\n        name: last_name(user),\\n        status: last_status(user),\\n        trial_days: last_trial_days(user)\\n      }\\n    end\\n    users\\n  end\\n\\n  private\\n\\n  def last_name(user)\\n    if user.last_subscription && user.last_subscription.respond_to?(:name)\\n      user.last_subscription.name\\n    else\\n      'none'\\n    end\\n  end\\n\\n  def last_status(user)\\n    if user.last_subscription && user.last_subscription.respond_to?(:status)\\n      user.last_subscription.status\\n    else\\n      '-'\\n    end\\n  end\\n\\n  def last_trial_days(user)\\n    if user.last_subscription && user.last_subscription.respond_to?(:trial_days)\\n      user.last_subscription.trial_days\\n    else\\n      '-'\\n    end\\n  end\\nend\\n\\n\")), mdx(\"p\", null, \"The basic idea behind this refactoring was to have a subscription object in preform\\nthat would always be able to respond to the methods called on it. So when\\nnull would have originally been returned, instead a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NullSubscription\"), \" object which responds\\nto these methods is returned. Transforming all of that code to this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"My Revision\",\n    \"My\": true,\n    \"Revision\": true\n  }), \"\\nclass StatusReportJob\\n  def perform\\n    users = {}\\n    User.all.map do |user|\\n      last_subscription = user.last_subscription\\n      users[user.name] = {\\n        name: last_subscription.name,\\n        status: last_subscription.status,\\n        trial_days: last_subscription.trial_days\\n      }\\n    end\\n    users\\n  end\\nend\\n\\n\")), mdx(\"p\", null, \"with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Subscription\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NullSubscription\"), \" class defined like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"My Revision Classes\",\n    \"My\": true,\n    \"Revision\": true,\n    \"Classes\": true\n  }), \"\\nclass Subscription\\n  def name\\n    'Monthly Subscription'\\n  end\\n  def status\\n    'active'\\n  end\\n  def trial_days\\n    14\\n  end\\n  def cancel\\n    # telling payment gateway...\\n    true\\n  end\\nend\\n\\nclass User\\n  # ...\\n\\n  def last_subscription\\n    subscriptions.last || NullSubscription.new\\n  end\\n\\n  # ...\\nend\\n\\n\\nclass NullSubscription\\n  def cancel\\n    false\\n  end\\n\\n  def name\\n    'none'\\n  end\\n\\n  def status\\n    '-'\\n  end\\n\\n  def trial_days\\n    '-'\\n  end\\nend\\n\\n\")), mdx(\"p\", null, \"As you can see last_subscription tries to find your last subscription for you,\\nbut when it fails it returns a new instance of NullSubscription. Then when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"last_subscription.name\"), \"\\nis called, we get \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'none'\"), \" returned if it dosen't exist, or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'Monthly Subscription'\"), \" if it does.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\"\n  }), \"\\nusers[user.name] = {\\n  name: last_subscription.name, # => 'none' or Monthly Subscription\\n  status: last_subscription.status,\\n  trial_days: last_subscription.trial_days\\n}\\n\\nclass Subscription\\n  def name\\n    'Monthly Subscription'\\n  end\\n\\n  #...\\n\\nend\\n\\n\\nclass NullSubscription\\n  def name\\n    'none'\\n  end\\n\\n  #...\\n\\nend\\n\\n\")), mdx(\"p\", null, \"##We Can Rebuild Him, We Have the Technology\"), mdx(\"p\", null, \"Now for some truly horrific code. This is the code one comes up with when they are\\nwrestling to get something to work and just keep throwing lines at it hoping\\nsomething will stick. Now it's time to refactor it and make it not only work, but\\nalso have it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"look\"), \" like it works.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"3-replace-method-with-method-object https://github.com/tute/refactoring-workshop/blob/master/3-replace-method-with-method-object/app.rb Full Source Code\",\n    \"3-replace-method-with-method-object\": true,\n    \"https://github.com/tute/refactoring-workshop/blob/master/3-replace-method-with-method-object/app.rb\": true,\n    \"Full\": true,\n    \"Source\": true,\n    \"Code\": true\n  }), \"\\n# 1. Create a class with same initialization arguments as BIGMETHOD\\n# 2. Copy & Paste the method's body in the new class, with no arguments\\n# 3. Replace original method with a call to the new class\\n# 4. Apply \\\"Intention Revealing Method\\\" to the new class. Woot!\\nclass Formatter\\n  # More code, methods, and stuff in this big class\\n\\n  def row_per_day_format(file_name)\\n    file = File.open file_name, 'r:ISO-8859-1'\\n    # hash[NivelConsistencia][date] = [[value, status]]\\n    hash = { '1' => {}, '2' => {} }\\n    dates = []\\n    str = ''\\n    CSV.parse(file, col_sep: ';').each do |row|\\n      next if row.empty?\\n      next if row[0] =~ /^\\\\/\\\\//\\n      date = Date.parse(row[2])\\n      (13..43).each do |i|\\n        measurement_date = date + (i-13)\\n\\n        # If NumDiasDeChuva is empty it means no data\\n        value  = row[7].nil? ? -99.9 : row[i]\\n        status = row[i + 31]\\n        hash_value = [value, status]\\n\\n        dates << measurement_date\\n        hash[row[1]][measurement_date] = hash_value\\n      end\\n    end\\n\\n    dates.uniq.each do |date|\\n      if !hash['1'][date].nil? && hash['2'][date].nil?\\n        # Only 'bruto' (good)\\n        value = hash['1'][date]\\n        str << \\\"#{date}\\\\t#{value[0]}\\\\t#{value[1]}\\\\n\\\"\\n      elsif hash['1'][date].nil? && !hash['2'][date].nil?\\n        # Only 'consistido' (kind of good)\\n        value = hash['2'][date]\\n        str << \\\"#{date}\\\\t#{value[0]}\\\\t#{value[1]}\\\\n\\\"\\n      else\\n        # 'bruto' y 'consistido' (has new and old data)\\n        old_value = hash['1'][date]\\n        new_value = hash['2'][date]\\n        str << \\\"#{date}\\\\t#{new_value[0]}\\\\t#{old_value[1]}\\\\t#{old_value[0]}\\\\n\\\"\\n      end\\n    end\\n\\n    str\\n  end\\n\\n  # More code, methods, and stuff in this big class\\nend\\n\\n\")), mdx(\"p\", null, \"Now the idea here was to dismantel this method into its components, I gave it\\nmy best but his solution was a little more elagent so I've decided to use his instead.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"Tute Costa's Solution https://github.com/tute/refactoring-workshop/blob/tute-solutions/3-replace-method-with-method-object/app-solution-tute.rb Full Source Code\",\n    \"Tute\": true,\n    \"Costa's\": true,\n    \"Solution\": true,\n    \"https://github.com/tute/refactoring-workshop/blob/tute-solutions/3-replace-method-with-method-object/app-solution-tute.rb\": true,\n    \"Full\": true,\n    \"Source\": true,\n    \"Code\": true\n  }), \"\\nclass FormatAtoB\\n  SIN_DATOS = -99.9\\n\\n  def initialize(file_name)\\n    @file_name = file_name\\n    @hash  = { '1' => {}, '2' => {} }\\n    @dates = []\\n  end\\n\\n  def perform\\n    load_format_a_file\\n    format_data_to_b\\n  end\\n\\n  private\\n\\n  def load_format_a_file\\n    file = File.open @file_name, 'r:ISO-8859-1'\\n    CSV.parse(file, col_sep: ';').each do |row|\\n      next if row.empty? || row[0] =~ /^\\\\/\\\\//\\n      load_month_in_hash(row)\\n    end\\n  end\\n\\n  def format_data_to_b\\n    formatted_rows = @dates.uniq.map { |date| formatted_row_for(date) }\\n    \\\"#{formatted_rows.join(\\\"\\\\n\\\")}\\\\n\\\"\\n  end\\n\\n  def formatted_row_for(date)\\n    old_value = @hash['1'][date]\\n    new_value = @hash['2'][date]\\n    if dato_bruto?(date)\\n      day = [date, old_value[0], old_value[1]]\\n    elsif dato_consistido?(date)\\n      day = [date, new_value[0], new_value[1]]\\n    else # 'bruto' y 'consistido'\\n      day = [date, new_value[0], old_value[1], old_value[0]]\\n    end\\n    day.join(\\\"\\\\t\\\")\\n  end\\n\\n  def load_month_in_hash(row)\\n    @beginning_of_month = Date.parse(row[2])\\n    (13..43).each do |i|\\n      load_day_in_hash(row, i)\\n    end\\n  end\\n\\n  def load_day_in_hash(row, i)\\n    nivel_consistencia = row[1]\\n    date = @beginning_of_month + (i - 13)\\n    @dates << date\\n    @hash[nivel_consistencia][date] = datos(row, i)\\n  end\\n\\n  # If NumDiasDeChuva is empty it means no data\\n  def datos(row, i)\\n    data = row[7].nil? ? SIN_DATOS : row[i]\\n    status = row[i + 31]\\n    [data, status]\\n  end\\n\\n  def dato_bruto?(date)\\n    @hash['1'][date] && @hash['2'][date].nil?\\n  end\\n\\n  def dato_consistido?(date)\\n    @hash['1'][date].nil? && @hash['2'][date]\\n  end\\nend\\n\\nclass Formatter\\n  def row_per_day_format(file_name)\\n    FormatAtoB.new(file_name).perform\\n  end\\nend\\n\\n\")), mdx(\"p\", null, \"There could still be a lot more done here, I mean are you really ever done refactoring?\\nBut I think this grasps some of the main ideas. You want to make use of instance variables\\nto allow for the method to be broken up without having to pass lists of\\nvariables from method to method. It is useful to find the variables that are inherent to the class itself.\\nMake those your instance variables. From there your goal is simpler, you need to\\nbasically construct these variables to some final product, one chunk at a time. There is still a lot going\\non here, but it definitely looks slightly less overwhelming when looking at manageable chunks.\"), mdx(\"p\", null, \"The best part is that you now have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FormatAtoB\"), \" class that can go in its own file. You shouldn't have to add much to this file\\nin the future since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtoB\"), \" is not likely to change since A should remain A and like wise with B. More importantly\\nyou have a much cleaner \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Formatter\"), \" class, now when you need a new format you can add that class to its own file and\\njust worry about calling the right one in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Formatter\"), \". Now each class has a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://en.wikipedia.org/wiki/Single_responsibility_principle\"\n  }), \"single responsibility\"), \"\\n, and is much less dependent on future changes making your code much more \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://en.wikipedia.org/wiki/Solid_%28object-oriented_design%29\"\n  }), \"SOLID\"), \".\"), mdx(\"p\", null, \"##Getting the User Into Shape\"), mdx(\"p\", null, \"For this last part, I need one to imagine a massive user model. This refactoring\\non its own may seem like it is making it more complicated, but when one realizes\\nthat they are moving all of this code out of a bloated class it makes more sense.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"4-service-objects https://github.com/tute/refactoring-workshop/blob/master/4-service-objects/app.rb Full Source Code\",\n    \"4-service-objects\": true,\n    \"https://github.com/tute/refactoring-workshop/blob/master/4-service-objects/app.rb\": true,\n    \"Full\": true,\n    \"Source\": true,\n    \"Code\": true\n  }), \"\\nclass User\\n  attr_accessor :subscription\\n\\n  # validations\\n  # callbacks\\n  # authentication logic\\n  # notifications logic\\n\\n  def subscribe\\n    api_result = try_api { PaymentGateway.subscribe }\\n    if api_result == :success\\n      self.subscription = :monthly_plan\\n    end\\n    api_result\\n  end\\n\\n  def unsubscribe\\n    api_result = try_api { PaymentGateway.unsubscribe }\\n    if api_result == :success\\n      self.subscription = nil\\n    end\\n    api_result\\n  end\\n\\n  private\\n\\n  # Try API connection, trap and log it on failures\\n  def try_api\\n    yield\\n  rescue SystemCallError => e\\n    # log API connection failure\\n    :network_error\\n  end\\n\\n  # Other private methods\\nend\\n\\n\")), mdx(\"p\", null, \"Now all of this code really should be part of some subscription class, but since it\\ndepends on the user it seems to have just been crammed into this model. It doesn't\\nlook like much, but remember this is a user model that typically has hundreds of other\\nlines of code, likely with more examples of logic that need to be moved out as well.\\nTo move this code out though you are going to need pass along the user. Originally I wanted to make\\nan instance variable called user and pass him into the initialization, but I found out\\nthat there is a slightly sexier way to go about it through the use of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Struct\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ruby\",\n    \"metastring\": \"Tute Costa's Solution https://github.com/tute/refactoring-workshop/blob/tute-solutions/4-service-objects/app-solution-tute.rb Full Source Code\",\n    \"Tute\": true,\n    \"Costa's\": true,\n    \"Solution\": true,\n    \"https://github.com/tute/refactoring-workshop/blob/tute-solutions/4-service-objects/app-solution-tute.rb\": true,\n    \"Full\": true,\n    \"Source\": true,\n    \"Code\": true\n  }), \"\\nclass SubscriptionService < Struct.new(:user)\\n  def subscribe\\n    api_result = try_api { PaymentGateway.subscribe }\\n    if api_result == :success\\n      user.subscription = :monthly_plan\\n    end\\n    api_result\\n  end\\n\\n  def unsubscribe\\n    api_result = try_api { PaymentGateway.unsubscribe }\\n    if api_result == :success\\n      user.subscription = nil\\n    end\\n    api_result\\n  end\\n\\n  private\\n\\n  # Try API connection, trap and log it on failures\\n  def try_api\\n    yield\\n  rescue SystemCallError => e\\n    # log API connection failure\\n    :network_error\\n  end\\nend\\n\\nclass User\\n  attr_accessor :subscription\\n\\n\\n  # Podr\\xEDa ser delegate :subscribe, :unsubscribe, to: :subscription_service\\n\\n  def subscribe\\n    subscription_service.subscribe\\n  end\\n\\n  def unsubscribe\\n    subscription_service.unsubscribe\\n  end\\n\\n  private\\n\\n  def subscription_service\\n    @subscription_service ||= SubscriptionService.new(self)\\n  end\\nend\\n\\n\")), mdx(\"p\", null, \"This allows us to simply pass the user into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SubscriptionService.new(self)\"), \" and\\nfrom there we call user instead of self to get the desired results.\\nThis really cleans up the user model. I also want to point out how through\\nthe use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@subscription_service ||= SubscriptionService.new(self)\"), \" we ensure\\nthat a new instance is only created if we need it. We didn't even change the users\\nAPI since it still has a suscribe and unsubscribe method, they just employ the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"subscription_service\"), \" class. This means that all of our original tests should\\nbe completely unaffected.\"), mdx(\"p\", null, \"##Summary\"), mdx(\"p\", null, \"In summary the biggest favor you can do yourself before refactoring is to make sure\\nyou have a comprehensive test suit. Once that is in place you are able to freely change\\ncode without having to worry about secretly breaking functionality. To give this a try\\nfor yourself fork the repository here \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"https://github.com/tute/refactoring-workshop\"), \",\\nand refactor away. Run the tests suit to ensure you didn't break anything. Good luck, and happy\\ncoding.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Takeaways From RailsConf 2014","date":"May 14th, 2014"}}},"pageContext":{"id":"3f95e968-8397-5356-a5ab-0c76123d1b8f"}},"staticQueryHashes":["3649515864","63159454"]}