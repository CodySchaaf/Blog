{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/2015-10-07-angular-currency-input-directive/","result":{"data":{"mdx":{"id":"56b0c9c1-d243-5087-8c88-17818ce0ca7c","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"Angular Currency Input Directive\",\n  \"date\": \"2015-10-07T07:02:00.000Z\",\n  \"comments\": true,\n  \"tags\": [\"angular\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This directive turns a regular input element into an auto formatting currency input directive.\\nIt adds the correct number of commas into the number as you type. This is something, that if done\\npoorly, can be incredibly annoying, but\", \"\\u2014\", \"as I hope I have done\", \"\\u2014\", \"if implemented well\\ncan be a very helpful ux enhancement.\"), mdx(\"p\", null, \"To use this directive you can bower install the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cs-angular-currency-input\"), \"\\npackage and including the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"csCurrencyInput\"), \" module in you angular app. Check out the readme on\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/CodySchaaf/CsCurrencyInput\"\n  }), \"GitHub\"), \". You could also include the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app/build/index.js\"), \"\\nfile directly into your project, or follow along and build your own!\"), mdx(\"p\", null, \"#What you'll be making\"), mdx(\"iframe\", {\n    height: \"265\",\n    style: {\n      \"width\": \"100%\"\n    },\n    scrolling: \"no\",\n    title: \"Angular Currency Input\",\n    src: \"https://codepen.io/codyschaaf/embed/GprYyR?height=265&theme-id=light&default-tab=html,result\",\n    frameBorder: \"no\",\n    loading: \"lazy\",\n    allowtransparency: \"true\",\n    allowFullScreen: true\n  }, \"See the Pen \", mdx(\"a\", {\n    href: \"https://codepen.io/codyschaaf/pen/GprYyR\"\n  }, \"Angular Currency Input\"), \" by Cody Schaaf (\", mdx(\"a\", {\n    href: \"https://codepen.io/codyschaaf\"\n  }, \"@codyschaaf\"), \") on \", mdx(\"a\", {\n    href: \"https://codepen.io\"\n  }, \"CodePen\"), \".\"), mdx(\"p\", null, \"#Directive Implementation\"), mdx(\"p\", null, \"To start we will define the csCurrencyInput directive. Note the cs prefix is used to prevent collisions with\\nstandard HTML attributes. This directive will require ngModel to allow it to hook into the input element's\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.angularjs.org/api/ng/type/ngModel.NgModelController\"\n  }), \"ngModelController\"), \".\\nAs well as a Link function definition which will allow us to work with the ngModelController.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"csCurrencyInput.directive('csCurrencyInput', (): ng.IDirective => {\\n    return {\\n      restrict: 'A',\\n      require:  'ngModel',\\n      scope:    true,\\n      link:     (scope: ng.IScope, element: ng.IAugmentedJQuery, attributes: ng.IAttributes, ngModelController: ng.INgModelController): Link => {\\n        return new Link(ngModelController);\\n      },\\n    };\\n});\\n\\n\")), mdx(\"p\", null, \"For the link function implementation I have made a utility class to help with some of the string manipulation.\\nAny method called on the Str class can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/CodySchaaf/CsCurrencyInput/blob/master/app/src/strings.ts\"\n  }), \"here\"), \".\\nI Will go over some of the more complicated methods at the end.\"), mdx(\"p\", null, \"To start we need to add a new parser and formatter to our ngModelController. Typically you want push parsers\\nonto \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.angularjs.org/api/ng/type/ngModel.NgModelController#$parsers\"\n  }), \"ngModelController's $parsers\"), \"\\narray since they are run in order, and you want to unshift your formatter onto\\nthe \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.angularjs.org/api/ng/type/ngModel.NgModelController#$formatters\"\n  }), \"$formatters\"), \"\\narray since formatters are run in reverse order. This is something you'd need to think about\\nwhenever adding a new function since it all depends on the implementation.\"), mdx(\"p\", null, \"###Priority\"), mdx(\"p\", null, \"Parsers and formatters will be added depending on the order the directive is instantiated, so look at the\\npriority of the directive (defined in the directive definition). If no priority is specified then it default\\nto 0. Priority queues up the directives controllers in order (highest to lowest), and the directives link functions in reverse order.\\nRemember a priority can be negative, and is only taken into consideration if two directives are present on the\\nsame element.\"), mdx(\"p\", null, \"Pay specially attention to this relationship if you need to put two directives on a single element that both require\\nthe ngModel.\"), mdx(\"p\", null, \"###Parsers\"), mdx(\"p\", null, \"Parsers are Angular's pipeline that connect the view value to what is stored in the ngModel expression.\\nFor instance by default the input directive will show a string in the view as well as store\\na string in the ngModel that is passed into it. Angular allows you to change this behavior by passing\\nin a type. If you pass in a type of number, then angular will add a parser that converts the string into\\na number. This will mean that the internal ngModelController will have a viewValue that is a string and\\na modelValue that is a number. All you will know about it the model value that will be passed back to\\nyour ngModel expression as a number.\"), mdx(\"p\", null, \"Parsers are typically triggered by a call to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.angularjs.org/api/ng/type/ngModel.NgModelController#$setViewValue\"\n  }), \"$setViewValue\"), \",\\nwhich is called for you when using an input\\nelement.\"), mdx(\"p\", null, \"For the csCurrencyInput directive we will want to add a parser that converts the string to a number\\nthat the ngModel passed in can better handel. We will also call $setViewValue here to update the\\nviewValue with a nicely formatted version.\"), mdx(\"p\", null, \"You can think of parsers as pipes that take in user content and parse it into a version that the\\ncode is equipped to deal with.\"), mdx(\"p\", null, \"###Formatters\"), mdx(\"p\", null, \"Formatters are like parsers but they handle the reverse direction. They take changes to the ngModel\\nexpression and format them into a viewValue that the user can better understand.\"), mdx(\"p\", null, \"In our directive we will want to utilise them to convert default values, or values from the backend\\nthat are passed to our directive via the required ngModel directive, and format them for the user.\"), mdx(\"p\", null, \"#Implementation\"), mdx(\"p\", null, \"####Parser\"), mdx(\"p\", null, \"For the parser we take the input value, the value that the user has just typed, and we ensure it is not\\nempty (null undefined '' ect). If it is empty then we return null, this allows us to ensure only valid\\nvalues make it back to the model. We also want to test the value against a regular expression to ensure\\nit is a valid currency. For the current implementation we will use a regexp that allows both positive and negative\\ncurrency values. The regex \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"negativeNumberPattern = /^(?:-\\\\$|\\\\$-|-|\\\\$)?[0-9,]+(?:.[0-9]+)?$/\"), \" first optionally matches\\n$ and/or - in any order, then matches any number of numbers and commas, and finally matches decimal point followed\\nby any number of additional numbers.\"), mdx(\"p\", null, \"After we validate the input we need to break the number up into its components. We split the input at\\nthe decimal point. This allows us to add commas to the integer component, and leave the deimal part unchanged.\"), mdx(\"p\", null, \"In order to add the commas we want to utilize \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\"\n  }), \"number's toLocalString method\"), \".\\nFor example this will convert\\nnumber 1000 to the string 1,000. In my code I call addCommasToString, which is my browser compatible version (Located on the\\nStr class) of to local string. All browsers handle the decimal places differently, so we stripped them off to handle ourselves.\"), mdx(\"p\", null, \"After we have added the commas we need to see if we need to update the view value. To check this we sanitize\\nthe input value and the formatted value. All the sanitation does is strip any character that is not a number\\nor a comma. This is because we are looking to only add commas to our users number, so that is the only change\\nwe care about. After comparing these values, if we find they do not match we append the decimal places and prepend any\\nprefix (such as $) by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reassembleInput\"), \" and pass that to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$setViewValue\"), \" to update the models display value.\\nFinally we render any changes to the viewValue.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$setViewValue\"), \" will now call the parser again to ensure the correct value is passed to the model. This is a bit\\nweird, but allows for the smoothest update of the dom while keeping the model in sync as well as providing a very smooth\\nexperience for the user. This is the reason for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sanitizeNumberAsString\"), \" check, which will ensure this loop only executes\\ntwice for every model change. Finally we return the value that should be stored in the model by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stringToFloat\"), \"\\nwhich turns the string value from the input into a number.\"), mdx(\"p\", null, \"####Formatter\"), mdx(\"p\", null, \"The formatter is a bit simpler. Since its job is updating the view value with its return value, all we have\\nto do is return the formatted value. In the formatter we want to always ensure the value the backend has is\\ndisplayed in the view, not returning null if the value is bad for example as we did above. This is because we want to prevent\\nthe values from getting out of sync, and allow the user to fix any bad value. Then we call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"addCommasToString\"), \" on the integer part of\\nthe number, and finally return the reconstructed number.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"class Link {\\n\\n    private attachModelPipelines(ngModelController: ng.INgModelController): void {\\n      ngModelController.$parsers.push((inputValue: string): number => {\\n        if (!inputValue) return null;\\n        if (!Str.negativeNumberPattern.test(inputValue)) return null;\\n\\n        var components:  string[] = inputValue.split(\\\".\\\");\\n        var integerPart: string   = components[0];\\n\\n        var normalizedString: string = Str.addCommasToString(integerPart);\\n\\n        if (Str.sanitizeNumberAsString(normalizedString) !== Str.sanitizeNumberAsString(integerPart)) {\\n          var formattedNumber: string = Link.reassembleInput(inputValue, normalizedString);\\n          ngModelController.$setViewValue(formattedNumber); //$setViewValue will call parsers again, so ensure sanitized strings match to prevent infinite loop\\n          ngModelController.$render();\\n        }\\n        return Str.stringToFloat(inputValue);\\n      });\\n\\n      ngModelController.$formatters.unshift((inputValue: string): string => {\\n        var stringValue = String(inputValue);\\n        var formattedString: string = Str.addCommasToString(Str.getIntegerPart(stringValue));\\n        return Link.reassembleInput(stringValue, formattedString);\\n      });\\n    }\\n\\n    private static reassembleInput(input: string, normalizedString: string): string {\\n      var decimal:                string = Str.getDecimalPart(input);\\n      var dollarSignNegativeSign: string = input.match(/^(?:-\\\\$|\\\\$-|-|\\\\$)?/)[0];\\n\\n      return dollarSignNegativeSign + normalizedString + decimal;\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Now we need to call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attachModelPipelines\"), \" method in the constructor to ensure that when\\nthe directive is instantiated the pipelines are installed.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"class Link {\\n    constructor(ngModelController: ng.INgModelController) {\\n      this.attachModelPipelines(ngModelController);\\n    }\\n}\\n\")), mdx(\"p\", null, \"All together we have\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\nclass Link {\\n    constructor(ngModelController: ng.INgModelController) {\\n      this.attachModelPipelines(ngModelController);\\n    }\\n\\n    private attachModelPipelines(ngModelController: ng.INgModelController): void {\\n      ngModelController.$parsers.push((inputValue: string): number => {\\n        if (!inputValue) return null;\\n        if (!Str.negativeNumberPattern.test(inputValue)) return null;\\n\\n        var components:  string[] = inputValue.split(\\\".\\\");\\n        var integerPart: string   = components[0];\\n\\n        var normalizedString: string = Str.addCommasToString(integerPart);\\n\\n        if (Str.sanitizeNumberAsString(normalizedString) !== Str.sanitizeNumberAsString(integerPart)) {\\n          var formattedNumber: string = Link.reassembleInput(inputValue, normalizedString);\\n          ngModelController.$setViewValue(formattedNumber); //$setViewValue will call parsers again, so ensure sanitized strings match to prevent infinite loop\\n          ngModelController.$render();\\n        }\\n        return Str.stringToFloat(inputValue);\\n      });\\n\\n      ngModelController.$formatters.unshift((inputValue: string): string => {\\n        if (!inputValue) return null;\\n        var stringValue = String(inputValue);\\n        if (!Str.negativeNumberPattern.test(stringValue)) return null;\\n        var formattedString: string = Str.addCommasToString(Str.getIntegerPart(stringValue));\\n        return Link.reassembleInput(stringValue, formattedString);\\n      });\\n    }\\n\\n    private static reassembleInput(input: string, normalizedString: string): string {\\n      var decimal:                string = Str.getDecimalPart(input);\\n      var dollarSignNegativeSign: string = input.match(/^(?:-\\\\$|\\\\$-|-|\\\\$)?/)[0];\\n\\n      return dollarSignNegativeSign + normalizedString + decimal;\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Now lets add some model validation to our directive. A simple ng-require can handle the\\nrequire validation for the directive, but to prevent users of our directive from having to\\nimplement their own pattern validation (as well as allowing us to add custom patterns later),\\nwe will implement a simple pattern validator.\"), mdx(\"p\", null, \"Our angular models have another array on them called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.angularjs.org/api/ng/type/ngModel.NgModelController#$validators\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"$validators\")), \"\\nthat will store any validators that you want to run on your model when the value changes. These validators will\\nget passed both the modelValue and the viewValue.\"), mdx(\"p\", null, \"Since our model value should be null only if our view value is invalid (see parser above) we will check to\\nensure it is null and then decide which value should be focused on based on that.\\nIf it is not null then we should ensure that the value that was stored there is valid, otherwise\\nwe test the view value.\"), mdx(\"p\", null, \"We also want to short circuit this testing if the value is empty, since an empty value in angular is usually\\nconsidered a valid pattern and ng-require will take care of the missing validity.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"class Link {\\n\\n    private attachValidation(ngModelController: ng.INgModelController): void {\\n      ngModelController.$validators['pattern'] = (modelValue: number, viewValue: string): boolean => {\\n        var value = modelValue == null ? viewValue : String(modelValue);\\n        return ngModelController.$isEmpty(viewValue) || Str.negativeNumberPattern.test(value)\\n      };\\n    }\\n}\\n\\n\")), mdx(\"p\", null, \"Lets add this method call to the constructor as well.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"class Link {\\n    constructor(ngModelController: ng.INgModelController) {\\n      this.attachValidation(ngModelController);\\n      this.attachModelPipelines(ngModelController);\\n    }\\n}\\n\\n\\n\")), mdx(\"p\", null, \"At this point we have a pretty solid input field, yet it is still a bit naive. It works great when the user is just typing,\\nbut falls apart if they try and select a section, or otherwise edit the inner values. Also it gets a bit out of hand if\\nthey try and delete the commas we added for them.\"), mdx(\"p\", null, \"To remedy this next we will add some key press event handlers to help the user out. This is the make or break part of the\\ndirective, the part that can either feel very professional and polished or annoying and amateur. So lets take some time and get this right.\"), mdx(\"p\", null, \"coming soon...\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Angular Currency Input Directive","date":"October 7th, 2015","tags":["angular"]}}},"pageContext":{"id":"56b0c9c1-d243-5087-8c88-17818ce0ca7c"}},"staticQueryHashes":["3649515864","3897982121","3897982121"]}