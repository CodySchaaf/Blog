{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/2017-05-07-exploring-options-in-javascript-typescript/","result":{"data":{"mdx":{"id":"48911d40-028a-5b2c-ae26-8a1f39902e62","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"post\",\n  \"title\": \"Exploring Options in Javascript/TypeScript\",\n  \"date\": \"2017-05-07T07:36:20.000Z\",\n  \"comments\": true,\n  \"categories\": \"typescript options\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Why TypeScript and Options\"), mdx(\"p\", null, \"For the past few years at \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"www.sigfig.com\"\n  }), \"SigFig\"), \" we have been using \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.typescriptlang.org/\"\n  }), \"TypeScript\"), \", it makes refactoring\\nand working with a large code base/large team a lot more simple. A large variety of bugs\\ncan be caught during the build phase allowing \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Continuous_integration\"\n  }), \"CI\"), \"\\nto reject the pull request. Another great tool--and the subject of this post--has been our Option library.\\nThe build will break if you try and use a value that may be undefined without unwrapping it, or if an method signature\\nwas changed and some callers are incorrectly using it.\"), mdx(\"p\", null, \"Options allow for a stricter api, and ensure the user is ready for null return values. They also keep with the\\ntraditional iterator apis, which allows for nice \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\"\n  }), \"polymorphism\"), \"\\nand a consistent functional programming approach.\\nYou can think of an option similarly to an array with 0 or 1 value. You can then either map over the value, forEach\\nit, and even check if it contains a value. While we don't have to worry about methods throwing exception when empty\\nlike in many other languages, it is still use full in javascript when dealing with undefined returned values.\"), mdx(\"p\", null, \"Languages like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.scala-lang.org/api/current/scala/Option.html\"\n  }), \"Scala\"), \",\\nwho treat Options as first class, for example would return options for the following\\nsimilar javascript methods:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"Array.prototype.pop // See List.tailOption\\nArray.prototype.find // See List.find\\nObject[Key] // See Map.get\\n\")), mdx(\"p\", null, \"This requires the caller to \\\"unwrap\\\" the option if they want to use it and always be prepared to handle the null\\npossibility.\"), mdx(\"p\", null, \"Method signatures will also often require options to allow for cleaner internal code. If a parameter is optional\\nit will be an option and the internal code can handle it with a more functional approach instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"if\"), \" statements. The\\nbiggest advantage here is if someone modifies this internal code they will not make the mistake of using an optional\\nparameter without checking its availability first.\"), mdx(\"p\", null, \"For more information on scala options check out this guide to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html\"\n  }), \"The Option Type\"), \".\"), mdx(\"h2\", null, \"The cs-options Library\"), mdx(\"p\", null, \"If you would like to include an options library in your code \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cs-options\"), \" can be included with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bower install cs-option\"), \"\\nor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm install cs-option\"), \" package and require Option via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import {Option} from 'cs-option'\"), \". Check out the readme on\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/CodySchaaf/CsOption\"\n  }), \"GitHub\"), \".\"), mdx(\"p\", null, \"I have come up with some pretty contrived examples--about a family and their pet--that I will go over one at a time to discus the different methods, followed\\nby the entire example at the \", mdx(\"a\", {\n    href: \"#entire-example\",\n    className: \"link\"\n  }, \"bottom of this page\"), \" in both javascript and typescript. The examples will be in TypeScript\\nsince the options library really shines when it is used with strict typing and reads very similar to javascript, but they will be paired with some javascript repls\\nso you can play with them yourself.\"), mdx(\"h2\", null, \"How to make an Option\"), mdx(\"p\", null, \"You can make an option from an existing value with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Option.fromNullable\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Option.of\"), \", and you can make\\nan empty option with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Option.absent\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const Option = require('cs-option');\\n\\nconst arr = [1]\\n\\nconst options = {\\n    optionA: Option.fromNullable(arr.pop()),\\n    optionB: Option.fromNullable(arr.pop()),\\n    optionC: Option.of(1),\\n    optionD: Option.absent()\\n}\\n\\n\")), mdx(\"p\", null, \"The method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fromNullable\"), \" is typically used to wrap an external method call which returns an untrusted value\\n(possibly null). In my example I will use it when popping an element from an array, but could also be paired\\nwith find, or when reading a value from a map. In this example I want to feed one of my animals and need to\\nget food, I want to pop this off the food array so I wrap it in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Option.fromNullable\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \" getFood(): Option<number> {\\n    return Option.fromNullable(this.food.pop()); // or Option.pop(this.food)\\n  }\\n\")), mdx(\"p\", null, \"The method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"of\"), \" is used when you need to wrap a known value in an option. It will throw an error if the value is undefined.\\nIn my example I use this to pass a known value to a method that expects an option (since a family might or might not have a pet).\\nThis is because the parameter is optional, but makes the internal logic simpler when this is an option, as well as when the attribute is\\nread it is clear that it could be empty.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\nclass Family {\\n  constructor(public pet: Option<Pet>) {}\\n}\\n\\nnew Family(Option.of(blueTheCat));\\n\\n\")), mdx(\"p\", null, \"Finally an empty option can be created with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"absent\"), \", and should be used in the above example when you don't have a value to\\npass to a method, or assign an attribute.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"new Family(Option.absent());\\n\")), mdx(\"p\", null, \"##Working With Options\"), mdx(\"p\", null, \"Coming Soon...\"), mdx(\"h2\", null, \"Full Example\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"import {Option} from 'cs-option';\\n\\nclass PetType {\\n  static readonly DOG = 'DOG';\\n  static readonly CAT = 'CAT';\\n}\\n\\nclass Pet {\\n  type: PetType;\\n\\n  private energy = [] as number[];\\n\\n  constructor(public name: string) {}\\n\\n  eat(food: number) {\\n    this.energy.push(food);\\n  }\\n}\\n\\nconst blueTheCat = new Pet('Blue');\\nclass Family {\\n  private food = [1, 1, 1, 1];\\n  private secretStash = 1;\\n\\n  constructor(public pet: Option<Pet>) {\\n\\n  }\\n\\n  feedCats() {\\n    this.pet\\n      .filter(pet => pet.type === PetType.CAT)\\n      .forEach(this.feedPet.bind(this));\\n  }\\n\\n  callPet() {\\n    console.log(this.pet.map(p => p.name));\\n  }\\n\\n  feedBlue() {\\n    this.pet\\n      .filterValue(blueTheCat)\\n      .forEach(this.feedPet.bind(this));\\n  }\\n\\n  feedNotBlue() {\\n    this.pet\\n      .filterNotValue(blueTheCat)\\n      .forEach(this.feedPet.bind(this));\\n  }\\n\\n  getFood(): Option<number> {\\n    return Option.fromNullable(this.food.pop()); // or Option.pop(this.food)\\n  }\\n\\n  getFoodOrSecretStashFood(): Option<number> {\\n    return this.getFood().orElse(Option.of(this.secretStash));\\n  }\\n\\n  buyFood() {\\n    // decrement money\\n    return 1;\\n  }\\n\\n  feedPet(pet: Pet) {\\n    // example feed 1\\n    pet.eat(this.getFood().orThrow('No more food'));\\n    // example feed 2\\n    pet.eat(this.getFood().orCall(this.buyFood));\\n    // example feed 3\\n    pet.eat(this.getFood().or(this.secretStash));\\n    // example feed 4 not preferred since it is not as functional, but in certain instances can be helpful\\n    const food = this.getFood();\\n    if (food.isPresent()) { // or !food.isAbsent()\\n      pet.eat(food.get()); // will throw if empty\\n    } else {\\n      pet.eat(this.secretStash);\\n    }\\n  }\\n\\n  hasCat(): boolean {\\n    return this.pet.exists(p => p.type === PetType.CAT);\\n  }\\n\\n  hasBlue(): boolean {\\n    return this.pet.contains(blueTheCat);\\n  }\\n}\\n\\nclass Groomer {\\n  private waitingRoom = [new Family(Option.of(blueTheCat))];\\n  private kennel = [blueTheCat, new Pet('Merlin')];\\n\\n  groomPetFromWaitingRoom() {\\n    Option.pop(this.waitingRoom) // or  Option.fromNullable(this.waitingRoom.pop());\\n      .flatMap(f => f.pet)\\n      .forEach(this.groom);\\n  }\\n\\n  findBlue(): Option<Pet> {\\n    return Option.find(this.kennel, (p => p.name === 'Blue'));\\n  }\\n\\n  private groom() {}\\n}\\n\\n\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Exploring Options in Javascript/TypeScript","date":"May 7th, 2017"}}},"pageContext":{"id":"48911d40-028a-5b2c-ae26-8a1f39902e62"}},"staticQueryHashes":["3649515864","63159454"]}